[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18308262&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

# Part 1: Introduction to Software Engineering

1) Explain what software engineering is and discuss its importance in the technology industry. <br>

Software engineering refers to designing, developing, testing and maintaining software. It is important as it ensures the final product meets quality standard and user requirements through structured processes.

2) Identify and describe at least three key milestones in the evolution of software engineering.

### 1968 NATO Software Engineering Conference

- Description: Often regarded as the birth of software engineering as a formal discipline, this conference addressed the "software crisis" of the 1960s, where projects frequently exceeded budgets, missed deadlines, or failed entirely.

- Significance: It introduced the term "software engineering" and emphasized the need for systematic, disciplined approaches to software development, paving the way for structured methodologies.

### The Waterfall Model (1970)

- Description: Proposed by Winston Royce in his paper "Managing the Development of Large Software Systems," this model outlined sequential phases (requirements, design, implementation, testing, maintenance).

- Significance: While later criticized for rigidity, it established the foundation for structured software development processes and influenced subsequent methodologies like Agile.

### The Agile Manifesto (2001)

- Description: A group of developers published the Agile Manifesto, prioritizing flexibility, customer collaboration, iterative development, and responsiveness to change over rigid planning.

- Significance: It revolutionized software engineering by shifting focus from documentation-heavy processes to adaptive, user-centric approaches, leading to frameworks like Scrum and Kanban.

3) List and briefly explain the phases of the Software Development Life Cycle.

i) Requirement Analysis
   - Objective: Understand and document what the stakeholders need from the software.
   - Activities: Gather requirements through interviews, surveys, and workshops. Analyze and prioritize these requirements.
   - Deliverables: Software Requirements Specification (SRS) document.

2) Planning:
   - Objective: Define the project scope, objectives, and resources needed.
   - Activities: Create a project plan, including timelines, cost estimates, and resource allocation. Identify risks and mitigation strategies.
   - Deliverables: Project Plan, Risk Management Plan.

3) Design:
   - Objective: Create a blueprint for the software based on the requirements.
   - Activities: Design the system architecture, database structure, and user interfaces. Create detailed design documents.
   - Deliverables: System Design Document (SDD), UI/UX designs, Database schema.

4) Implementation (Coding):
   - Objective: Translate the design into executable code.
   - Activities: Write code according to the design specifications. Follow coding standards and best practices.
   - Deliverables: Source code, executable modules.

5) Testing:
   - Objective: Identify and fix defects in the software.
   - Activities: Conduct various types of testing (unit, integration, system, acceptance) to ensure the software meets the requirements.
   - Deliverables: Test cases, test results, defect reports.

6) Deployment:
   - Objective: Release the software to the end-users.
   - Activities: Deploy the software to the production environment. Conduct final testing and user training.
   - Deliverables: Deployed software, user manuals, training materials.

7) Maintenance:
   - Objective: Ensure the software continues to function correctly and efficiently after deployment.
   - Activities: Fix bugs, perform updates, and add new features based on user feedback.
   - Deliverables: Updated software, patch releases, documentation updates.

4) Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.<br>

The Waterfall methodology is a linear and sequential approach, characterized by distinct phases such as requirements, design, implementation, testing, and maintenance. It is rigid, with changes being difficult to implement once a phase is completed, and involves limited customer interaction, primarily at the beginning and end of the project. Extensive documentation is required at each phase, and risks are typically addressed late in the process. Waterfall is suitable for short-term projects with well-defined and stable requirements, such as developing a government compliance system where thorough documentation and adherence to strict regulations are crucial.

In contrast, the Agile methodology is iterative and incremental, focusing on continuous feedback and adaptation. It is highly flexible, welcoming changes even late in development, and involves continuous customer collaboration. Agile emphasizes minimal documentation and working software, with risks identified and mitigated early and continuously. This approach is ideal for long-term projects with evolving requirements, such as creating a mobile app for a startup where user needs and market conditions may change rapidly.

5) Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

   ### Software Developer
   ~ Developing applications, programs and systems using programming languages and frameworks.<br>
   ~ Maintaining and updating software to keep it functional.<br>
   ~ Collaborating with other team members to ensure best practices when developing software.<br>
   ~ Report to the project manager about the progress of the software development.

   ### Quality Assurance Engineer
   ~ Collaborate with stakeholders to understand and clarify software requirements.<br>
   ~ Create development standards and procedures for the programmers to follow.<br>
   ~ Confirm that the software meets the requirements before deployment.<br>
   ~ Analyse the product to identify bugs and suggest changes to make them more efficient.<br>
   ~ Develop and execute automation scripts using open-source tools.

   ### Project Manager
   ~ Discuss the project and its requirements with clients and software developers.<br>
   ~ Assemble and lead the software development team.<br>
   ~ Create the blueprint for the project, including the scope, allocating resources, setting deadlines and laying out communication strategies.<br>
   ~ Supervising each stage of the software development project.<br>
   ~ Set the budget and ensure the project adheres to it as closely as possible.<br>
   ~ Tracking and communicating information regarding the project milestones, deliverables and change requests.<br>
   ~ Deliver the completed software to the client and regularly check its performance. 


6) Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

~ The importance of IDEs is that they help developers to write, test and debug code more efficiently. For example VS code.

~ Version Control Systems(VCS) improve collaboration, streamline development, reduce errors and provides access to historical versions of a project for example Github.

7) What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.<br>

~ Rapid Technological Advancement - The rapid pace of technological advancement places considerable pressure on software engineers to stay current.<br>
  Solution: Software engineers should stand out by adopting continuous learning practices and using agile methodologies to adapt to emerging trends, keeping their skills sharp in an ever-evolving industry.

~ Growing Customer and Client Demands - Software engineers generally work on conceptual projects designed and developed to meet customer and client demands.<br>
Solution: Software engineers must understand underlying business concepts to ensure that the required features satisfy end usersâ€™ needs.

~ Software Security - Programming secure software is a complex and challenging task in part because cybercriminals can exploit many different types of vulnerabilities.<br>
Solution: Software engineers are to implement secure software features if they do not actively research ways to defend against hacking, malware, phishing, insider and third-party threats, and more.

~ Changing Software Requirements - Software requirements are often dynamic and subject to frequent changes, making it challenging for engineers to design and develop solutions that meet users' needs while accounting for future updates and bug fixes. This challenge becomes even more pronounced when creating cutting-edge software that users expect to rely on for years.<br>
Solution: To navigate these complexities, engineers can adopt approaches like agile development, which emphasizes iterative progress and adaptability, and modular design, which enables flexibility by breaking systems into manageable, independent components. Together, these strategies help engineers respond effectively to evolving requirements while maintaining high-quality outcomes.

8) Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.<br>

~ Unit testing - This it testing whereby the software is broken down into smaller components and subjected to rigorous testing.<br>
  Importance: It helps to identify bugs and errors early on and provide benefits that significantly enhance the development process hence improves the software quality.

~ Integration testing - It is the process of testing the interface between two software units.<br>
  Importance: It validates that different software components, subsystems or applications work together as a system to achieve the desired functionality and performance.

~ System testing - This is a critical phase in SDLC that ensures the complete application functions as intended before release.<br>
  Importance: It ensures overall system integrity and functionality.

~ Acceptance testing - This is testing that ensures the software meets user needs and business requirements.<br>
  Importance: It ensures that the product meets user needs and business requirements.



# Part 2: Introduction to AI and Prompt Engineering

1) Define prompt engineering and discuss its importance in interacting with AI models. <br>

~ It refers to the process of designing AI inputs that will produce a quality output. It helps AI users to generate relevant results in the first prompt.

2) Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

~"Tell me something about space." - This is vague

"Tell me fun facts about the planets in our solar system!" - This is clear as the prompt is clear, specific and curious hence a better output is expected.
